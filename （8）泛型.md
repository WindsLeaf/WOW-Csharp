**泛型（Generic）** 允许您延迟编写类或方法中的编程元素的数据类型的规范，直到实际在程序中使用它的时候。换句话说，泛型允许您编写一个可以与任何数据类型一起工作的类或方法。

# Why？

泛型将类型参数的概念引入 .NET，这样可以设计一个或多个类型的规范。泛型有更好的**性能**，并且可以达到**类型安全**，还能够提升**代码复用率**。

比如说两个数组的实现方式，一个是`ArrayList`，一个是`List<T>` 。

看一下MSDN的`ArrayList`的一段反编译代码：

```c#
public virtual int Add(object? value)
{
    throw null;
}
```

可以看到`ArrayList`的Add方法的参数是默认值为null的object类型。当我们从`ArrayList`中取出数据时，

```c#
ArrayList arrayList = new ArrayList();
for (int i = 0; i < 10000; i++)
{
    arrayList.Add(i);
}
Console.WriteLine(arrayList[1].GetType());// System.Int32
```

我们可以清楚的看到存入的数据和取出的数据都是设置好的数据类型（System.Int32），也就是说在存入和取出数据的时候会存在装箱和拆箱的操作，这势必会使性能下降。

一个`ArrayList`实例化对象可以接受任何的数据类型，可是`List<T>`的实例化对象只能够接受指定好的数据类型。这样就保证了传入数据类型的一致，这就是所谓类型安全。

```c#
List<int> list = new List<int>();
list.Add(12);
//list.Add("12") error
```

## 泛型提升代码复用率

如果没有泛型，那么一个普通类类每涉及一个类型，就要重写类。这个可能说起来比较抽象，可以看一下下面这个demo：

```c#
class A
{
    public void GetTAndTest(int value)
    {
        Console.WriteLine(value.GetType());
    }
}
```

类型A的`GetTAndTest()`的参数类型仅仅是int类型，如果想要参数为string类型，方法的主体不变，如果没有泛型的话就只能重新写一个方法，如果想参数类型为double呢？那么就必须再重写一个方法……，**方法主体没有改变，却因为参数类型的不同而一遍又一遍的重写，这是不合理的**。所以要使用泛型，使用了泛型之后就不用再重写这么多次，demo如下：

```c#
class A<T>
{
    public void GetTAndTest(T value)
    {
        Console.WriteLine(value.GetType());
    }
}
```

有了泛型之后，当面对不同的参数类型有无限多，方法主体不变的情况时，使用泛型能够有效的提升代码复用率。

# 泛型类

泛型类封装不特定于特定数据类型的操作。 所谓泛型类就是在创建一个类的时候在后面加一个类似于`<T>`的标志。T就是该泛型类能够接受的数据类型。

下面定义一个泛型类：

```c#
class A<T>
{
    public void GetTAndTest(T value)
    {
        Console.WriteLine(value.GetType());
        Console.WriteLine(typeof(T) == value.GetType());
        // System.Int32
        // True
    }
}
```

采取类似下面的方法来实例化泛型类`A<T>`：

```c#
A<int> a = new A<int>();
a.GetTAndTest(12);
```

# 泛型方法

泛型方法是通过类型参数声明的方法，demo如下：

```c#
class FanXing
{
    public List<Object> ListObj { get; set; }
 
    /// <summary>
    /// 泛型方法
    /// </summary>
    /// <typeparam name="T">类型参数，示意任意类型</typeparam>
    /// <param name="value">类型参数的实例化对象</param>
    public void A<T>(T value)
    {
        ListObj.Add(value);
    }
 
}
```

下面显式当类型参数为string时，调用泛型方法`A<T>(T value)`：

```c#
// 实例化类
FanXing fanXing = new FanXing()
{
    ListObj = new List<object>()
};
// 调用泛型方法
fanXing.A<string>("1234");
// 打印
fanXing.ListObj.ForEach(item =>
                        {
                            Console.WriteLine(item);
                        });
```

还可省略类型参数，编译器将推断类型参数。比如`fanXing.A("1234")`和`fanXing.A<string>("1234")`是等效的。

如果泛型类的类型参数和泛型方法的类型参数是同一个字母，也就是说如果定义一个具有与包含类相同的类型参数的泛型方法，则编译器会生成警告 [CS0693](https://docs.microsoft.com/zh-cn/dotnet/csharp/misc/cs0693)，请考虑为此方法的类型参数提供另一标识符。

```c#
class GenericList<T>
{
    // CS0693
    void SampleMethod<T>() { }
}

class GenericList2<T>
{
    //No warning
    void SampleMethod<U>() { }
}
```

# 泛型约束关键字

## new

`new` 约束指定泛型类声明中的类型实参必须有公共的无参数构造函数。 也就是说若要使用 `new` 约束，则该类型不能为抽象类型。

使用方式如下：

```c#
class B<T> where T : new()
{
    public B()
    {
    }
    public B(T value)
    {
        Console.WriteLine(value);
    }
}
```

假设现在有一个接口类`AbB`和接口类的实现类`AbBExtend`，如果某泛型类使用了`new`约束，则`AbB`无法作为该泛型类的类型参数。

```c#
public void Four()
{
    // AdB为抽象类
    //B<AbB>(); error

    // AbBExtend为AdB抽象类的实现类
    new B<AbBExtend>(); // right

    // C为接口
    //new B<C>(); error
}
```

## where

> 泛型定义中的 `where` 子句指定对用作泛型类型、方法、委托或本地函数中类型参数的参数类型的约束。 约束可指定接口、基类或要求泛型类型为引用、值或非托管类型。 它们声明类型参数必须具备的功能。
>
> ---
>
> 来源：[where（泛型类型约束）- C# 参考 | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/where-generic-type-constraint)

说白了，where约束泛型参数是谁的派生类，是谁的实现类，即**约束泛型参数来自哪里**。

比如说，现在有一个抽象类`AdB`，想要泛型类`D<T>`的类型参数

> | 约束          | 说明                                                         |
> | ------------- | ------------------------------------------------------------ |
> | T：struct     | 类型参数必须是值类型。可以指定除 Nullable 以外的任何值类型。 |
> | T:class       | 类型参数必须是引用类型，包括任何类、接口、委托或数组类型。   |
> | T:new ()      | 类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时，new() 约束必须最后指定。 |
> | T：<基类名>   | 类型参数必须是指定的基类或派生自指定的基类。                 |
> | T：<接口名称> | 类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的。 |
> | T：U          | 为 T 提供的类型参数必须是为 U 提供的参数或派生自为 U 提供的参数。这称为裸类型约束. |
>
> ---
>
> 来源：[C# 泛型约束 xxx Where T：约束(二) - 赵青青 - 博客园 (cnblogs.com)](https://www.cnblogs.com/zhaoqingqing/p/3894229.html)

# LICENSE

已将所有引用其他文章之内容清楚明白地标注，其他部分皆为作者劳动成果。对作者劳动成果做以下声明：

copyright © 2021 苏月晟，版权所有。

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">作品</span>由<span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">苏月晟</span>采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。
