**泛型（Generic）** 允许您延迟编写类或方法中的编程元素的数据类型的规范，直到实际在程序中使用它的时候。换句话说，泛型允许您编写一个可以与任何数据类型一起工作的类或方法。

# Why？

泛型将类型参数的概念引入 .NET，这样可以设计一个或多个类型的规范。泛型有更好的**性能**，并且可以达到**类型安全**，还能够提升**代码复用率**。

比如说两个数组的实现方式，一个是`ArrayList`，一个是`List<T>` 。

看一下MSDN的`ArrayList`的一段反编译代码：

```c#
public virtual int Add(object? value)
{
    throw null;
}
```

可以看到`ArrayList`的Add方法的参数是默认值为null的object类型。当我们从`ArrayList`中取出数据时，

```c#
ArrayList arrayList = new ArrayList();
for (int i = 0; i < 10000; i++)
{
    arrayList.Add(i);
}
Console.WriteLine(arrayList[1].GetType());// System.Int32
```

我们可以清楚的看到存入的数据和取出的数据都是设置好的数据类型（System.Int32），也就是说在存入和取出数据的时候会存在装箱和拆箱的操作，这势必会使性能下降。

一个`ArrayList`实例化对象可以接受任何的数据类型，可是`List<T>`的实例化对象只能够接受指定好的数据类型。这样就保证了传入数据类型的一致，这就是所谓类型安全。

```c#
List<int> list = new List<int>();
list.Add(12);
//list.Add("12") error
```

## 泛型提升代码复用率

如果没有泛型，那么一个普通类类每涉及一个类型，就要重写类。这个可能说起来比较抽象，可以看一下下面这个demo：

```c#
class A
{
    public void GetTAndTest(int value)
    {
        Console.WriteLine(value.GetType());
    }
}
```

类型A的`GetTAndTest()`的参数类型仅仅是int类型，如果想要参数为string类型，方法的主体不变，如果没有泛型的话就只能重新写一个方法，如果想参数类型为double呢？那么就必须再重写一个方法……，**方法主体没有改变，却因为参数类型的不同而一遍又一遍的重写，这是不合理的**。所以要使用泛型，使用了泛型之后就不用再重写这么多次，demo如下：

```c#
class A<T>
{
    public void GetTAndTest(T value)
    {
        Console.WriteLine(value.GetType());
    }
}
```

有了泛型之后，当面对不同的参数类型有无限多，方法主体不变的情况时，使用泛型能够有效的提升代码复用率。

# 泛型类

泛型类封装不特定于特定数据类型的操作。 所谓泛型类就是在创建一个类的时候在后面加一个类似于`<T>`的标志。T就是该泛型类能够接受的数据类型。

下面定义一个泛型类：

```c#
class A<T>
{
    public void GetTAndTest(T value)
    {
        Console.WriteLine(value.GetType());
        Console.WriteLine(typeof(T) == value.GetType());
        // System.Int32
        // True
    }
}
```

采取类似下面的方法来实例化泛型类`A<T>`：

```c#
A<int> a = new A<int>();
a.GetTAndTest(12);
```

# 泛型方法

泛型方法是通过类型参数声明的方法，demo如下：

```c#
class FanXing
{
    public List<Object> ListObj { get; set; }
 
    /// <summary>
    /// 泛型方法
    /// </summary>
    /// <typeparam name="T">类型参数，示意任意类型</typeparam>
    /// <param name="value">类型参数的实例化对象</param>
    public void A<T>(T value)
    {
        ListObj.Add(value);
    }
 
}
```

下面显式当类型参数为string时，调用泛型方法`A<T>(T value)`：

```c#
// 实例化类
FanXing fanXing = new FanXing()
{
    ListObj = new List<object>()
};
// 调用泛型方法
fanXing.A<string>("1234");
// 打印
fanXing.ListObj.ForEach(item =>
                        {
                            Console.WriteLine(item);
                        });
```

还可省略类型参数，编译器将推断类型参数。比如`fanXing.A("1234")`和`fanXing.A<string>("1234")`是等效的。

如果泛型类的类型参数和泛型方法的类型参数是同一个字母，也就是说如果定义一个具有与包含类相同的类型参数的泛型方法，则编译器会生成警告 [CS0693](https://docs.microsoft.com/zh-cn/dotnet/csharp/misc/cs0693)，请考虑为此方法的类型参数提供另一标识符。

```c#
class GenericList<T>
{
    // CS0693
    void SampleMethod<T>() { }
}

class GenericList2<T>
{
    //No warning
    void SampleMethod<U>() { }
}
```

# 泛型约束关键字

## new

`new` 约束指定泛型类声明中的类型实参必须有公共的无参数构造函数。 也就是说若要使用 `new` 约束，则该类型不能为抽象类型。

使用方式如下：

```c#
class B<T> where T : new()
{
    public B()
    {
    }
    public B(T value)
    {
        Console.WriteLine(value);
    }
}
```

假设现在有一个接口类`AbB`和接口类的实现类`AbBExtend`，如果某泛型类使用了`new`约束，则`AbB`无法作为该泛型类的类型参数。

```c#
public void Four()
{
    // AdB为抽象类
    //B<AbB>(); error

    // AbBExtend为AdB抽象类的实现类
    new B<AbBExtend>(); // right
}
```

