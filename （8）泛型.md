**泛型（Generic）** 允许您延迟编写类或方法中的编程元素的数据类型的规范，直到实际在程序中使用它的时候。换句话说，泛型允许您编写一个可以与任何数据类型一起工作的类或方法。

# Why？

泛型将类型参数的概念引入 .NET，这样可以设计一个或多个类型的规范。泛型有更好的**性能**，并且可以达到**类型安全**。

比如说两个数组的实现方式，一个是`ArrayList`，一个是`List<T>` 。

看一下MSDN的`ArrayList`的一段反编译代码：

```c#
public virtual int Add(object? value)
{
    throw null;
}
```

可以看到`ArrayList`的Add方法的参数是默认值为null的object类型。当我们从`ArrayList`中取出数据时，

```c#
ArrayList arrayList = new ArrayList();
for (int i = 0; i < 10000; i++)
{
    arrayList.Add(i);
}
Console.WriteLine(arrayList[1].GetType());// System.Int32
```

我们可以清楚的看到存入的数据和取出的数据都是设置好的数据类型（System.Int32），也就是说在存入和取出数据的时候会存在装箱和拆箱的操作，这势必会使性能下降。

一个`ArrayList`实例化对象可以接受任何的数据类型，可是`List<T>`的实例化对象只能够接受指定好的数据类型。这样就保证了传入数据类型的一致，这就是所谓类型安全。

```c#
List<int> list = new List<int>();
list.Add(12);
//list.Add("12") error
```

# 泛型类

泛型类封装不特定于特定数据类型的操作。 所谓泛型类就是在创建一个类的时候在后面加一个类似于`<T>`的标志。T就是该泛型类能够接受的数据类型。

下面定义一个泛型类：

```c#
class A<T>
{
    public void GetTAndTest(T value)
    {
        Console.WriteLine(value.GetType());
        Console.WriteLine(typeof(T) == value.GetType());
        // System.Int32
        // True
    }
}
```

采取类似下面的方法来实例化泛型类A：

```c#
A<int> a = new A<int>();
a.GetTAndTest(12);
```

·
