# 前言

> “我花了几个星期…试着弄清楚“强类型”、“静态类型”、“安全”等术语，但我发现这异常的困难…这些术语的用法不尽相同，所以也就近乎无用。
>
> ---
>
> 来源：编程语言专家 [Benjamin C. Pierce](https://zh.wikipedia.org/w/index.php?title=Benjamin_C._Pierce&action=edit&redlink=1)

今天，我突然发现，我虽然自认为会几门编程语言和会使用几种框架，却对编程语言的原理的理解停留在十分浅薄的层面，我原先对编程语言的理解不过是编译器将语言编译成机器代码，然后机器再执行机器代码，解释型语言是解释器边解释边运行，我还知道像java这种语言是先编译成bytecode（class文件），然后在`jvm`里面用JIT即时编译……过去我对编程语言的理解仅仅限于上面这些。如果问我诸如**解释器和编译器的区别，即时编译、动态编译、AOT的异同，什么叫解释什么叫编译，静态语言和动态语言的区别，python算是强类型语言吗**等问题，我八成会答错，更让人沮丧的是在**很多博客网站上像`csdn`和简书里关于编程语言的基本认知错误有很多**，笔者通过广泛的阅读维基百科相关内容和大学教材《编译原理》，同时阅读了`msdn`的官方文档和知乎上一些高质量回答，写下本文，希望抛砖引玉的同时能够对互联网上一些关于编程语言的错误言论起到正本清源的作用。

# 什么是编程语言

> **编程语言**（英语：programming language），是用来定义[计算机程序](https://zh.wikipedia.org/wiki/计算机程序)的[形式语言](https://zh.wikipedia.org/wiki/形式語言)。它是一种被[标准化](https://zh.wikipedia.org/wiki/标准化)的交流技巧，用来向[计算机](https://zh.wikipedia.org/wiki/计算机)发出指令，一种能够让[程序员](https://zh.wikipedia.org/wiki/程序员)准确地定义计算机所需要使用数据的计算机语言，并精确地定义在不同情况下所应当采取的行动。
>
> ---
>
> 来源：[编程语言 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/编程语言)

编程语言，其实就是一个能够让计算机明白使用者意图，同时能让使用者对计算机发出指令的有统一规则的交流技巧。这里可以打个拟人化的比喻，`cpu`所能听懂的语言和人说的语言是不一样的，所以需要有一个中间语言——编程语言来搭建交流的桥梁，事实上从人类的语言到`cpu`能听懂的语言往往并不是一个编程语言就能办到的，通常需要多个编程语言参与其中。

**本篇文章的价值观为一切定义以维基百科为准，如果维基百科和《编译原理》的定义有冲突，则以《编译原理》为准。**

# 强弱与动静态，从C语言说起

先说结论，**c语言是弱类型、静态类型、有编译器的编译语言**。

**强弱类型和动静态类型不是一个东西，也不是一个标准下的产物。**

> 强类型：如果一门语言倾向于不对变量的类型做隐式转换，那我们将其称之为强类型语言
>
> 弱类型：相反，如果一门语言倾向于对变量的类型做隐式转换，那我们则称之为弱类型语言
>
> 动态类型：如果一门语言可以在运行时改变变量的类型，那我们称之为动态类型语言
>
> 静态类型：相反，如果一门语言不可以在运行时改变变量的类型，则称之为静态类型语言
>
> 
>
> 作者：网仙
> 链接：https://www.zhihu.com/question/43498005/answer/266431585
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

**强弱类型指的是类型检查的严格程度，动静态区分的是类型检查在程序运行的哪个阶段发生的。**（当然了，你如果说类型检查是早就在IDE编辑器里面发生的，那就没意思了。😶）

动态和静态往往是有比较明显的区分，可是强弱类型确实没有一条明显的分界线。就拿python来说，一个整数和浮点数相加会变成浮点数，这就是对变量的类型做了隐式变换。可是即使如此，python在大多数情况下是要比JavaScript这种语言更加的倾向于不做隐式变换，至少python不会去认为整数1和字符串1相等（当然，这得是在没有重写equals函数和没有自定义一个函数去主动将字符串转变为浮点数的情况下）。即使和大多数高级语言一样，在特定的时候会进行隐式转换，但是那是为了编程的方便，而不是因为自身的特性。

比如这段C#代码里面，试图去进行做隐式数据转换，可以看到即使在某些情况下这是被允许的，但是，c#的倾向为不做隐式转换。故而c#为强类型语言。

```c#
        /// <summary>
        /// 验证隐式变换
        /// </summary>
        internal void YinShiChange()
        {
            Console.WriteLine("-=-=-=-=-=-=-=-=-=-=-=-=");
            var a = 1;
            //a += "121"; 这是错误的
            Console.WriteLine(a.GetType());
            //在打印的时候是可以的，这时候是将所有的都转换成字符串
            Console.WriteLine(a + "123");
            var v = Convert.ToString(a);
            Console.WriteLine(v.GetType());
            Type intType = typeof(int);
            Console.WriteLine(intType == a.GetType());
            // 值类型的隐式转换
            var aa = 1;
            Console.WriteLine(intType == aa.GetType());
            double cc = aa;
            Console.WriteLine(cc.GetType() + "\t" + (cc.GetType() == typeof(double)));

            #region
            /*
            -=-=-=-=-=-=-=-=-=-=-=-=
            System.Int32
            1123
            System.String
            True
            True
            System.Double   True
            按下任何键去停止并退出程序
             */
            #endregion

        }
```

下面这张图片，清晰的说明了目前维基百科·对几种知名的语言的强弱类型和动静态类型的区分。事实上，在维基百科里面清楚的说明了**强弱类型**（Strong and weak typing）这两个术语并**没有非常明确的定义**。甚至python的作者吉多一度认为python属于弱类型语言。下面这个表格仅仅代表了目前比较主流的看法。

![b0aeb7ffd1667b9162e5329154d43777_720w.jpg (500×337) (zhimg.com)](https://pic2.zhimg.com/80/b0aeb7ffd1667b9162e5329154d43777_720w.jpg?source=1940ef5c)

## C语言是怎么运行的？

# python 是怎么运行的？

python语言在运行过程中，是先把python编译成一种叫做`pyc`的类似字节码的语言，然后`cpython`编译器将`pyc`文件逐步解释成机器代码来运行，`pyc`到机器代码这一步是逐句翻译（边运行边编译）的。

![](https://suyuesheng-biaozhun-blog-tupian.oss-cn-qingdao.aliyuncs.com/blogimg/20211112172310.png)

我们需要注意到的是python文件从`.py`到`.pyc`的过程并不属于AOT（预先编译），`.py`到`.pyc`的过程默认是在每一次的python运行过程中发生的。但是从`.py`到`.pyc`的过程可以用`python -m py_compile file.py`进行提前编译。

## python提前编译成字节码

这是一个one.py的普通文件：

```python
def forEachList(list):
    for i in list:
        if(i % 2 == 0):
            print(i)
        else:
            print("{}无法被整除".format(i))


if __name__ == '__main__':
    ll = []
    for i in range(0, 10):
        ll.append(i)
    forEachList(ll)
    print("hello wrold")
```

运行`python -m py_compile .\one.py`，就会目录变成以下样子：

```bash
.
├── __pycache__
│   └── one.cpython-38.pyc
└── one.py
```

`one.cpython-38.pyc`就是编译出的`pyc`文件，可以直接用`python .\one.cpython-38.pyc`来正常运行这个文件。

## 提前编译的好处

字节码在某种意义上会保护代码，让普通人无法直接看到代码内部的内容，但是这种保护措施在多如牛毛的反编译工具面前是没有什么意义的。另一方面，提前编译成字节码会省去编译代码的一道步骤，加快运行速度，事实上，像`cpython`这种没有JIT（即时编译）的解释器，最好是能直接编译成`native code`，因为`cpython`在代码运行过程中起到的优化作用有限，甚至所起到的优化作用比不上直接编译成`native code`的好处。

请注意，**`cython`≠`cpython`**，`cpython`是python官方的解释器，`Cython` 是包含 C 数据类型的 Python，Cython 是 Python，几乎所有 Python 代码都是合法的 Cython 代码。 （存在一些限制，但是差不多也可以。） Cython 的编译器会转化 Python 代码为 C 代码，这些 C 代码均可以调用 Python/C 的 API。

## 使用`cython`来达到AOT的效果

[`Cython`入门教程 - 簡書 (jianshu.com)](https://www.jianshu.com/p/cfcc2c04a6f5)

[README | `Cython` 官方文档中文版 (gitbooks.io)](https://moonlet.gitbooks.io/cython-document-zh_cn/content/index.html)

使用`cython`可以将pyx文件直接编译成`native code`，这大大提高运行效率，但是这个所谓的`native code`是离不开`cpython`解释器的，原因是因为现在的高级语言它需要解释器提供类库来达到最终的效果，如果python有像`dotnet`这种`self-contained`的模式并且可以自动裁剪未使用的程序集的话，就会方便很多，可是我并没有发现python有提供这样的功能（当然，可能会有一些开源的第三方工具来实现类似功能）。python官方也没有提供明确的python运行时下载地址（或者说整个python安装文件夹就是运行时），人们通常认为python安装文件夹内的`lib`文件夹为python标准库的地址，python.exe为python解释器。

在很多linux发行版的软件源中提供了名为python-dev的文件夹，里面包含了python运行所需要的调用python api的c/c++文件。

pyd文件的本质是一个动态链接库，这个没法直接运行，只能被调用。当然了，写一个命令，自动将pyd包裹进一个python文件，然后该文件调用pyd并运行指定的方法也是可行的。

# 运行时

运行时被叫做`runtime`，这是一个很形而上学的概念，可以将它看作是程序运行所必须的东西，这就叫运行时。

不同语言，不同解释器所定义的运行时内容是有不同的。比如说**java的运行时叫做jre**，它包含jvm虚拟机和运行时库，jvm虚拟机的作用就是对字节码进行JIT编译，内存管理，GC垃圾清理等功能，最终生成机器代码，将机器代码交给cpu执行。**.NET的运行时被称作是CLR（公共语言运行时）**，和java不同，尽管CLR 也是一种虚拟机，但是**.NET不像java一样对虚拟机单独命名（jvm）**，CLR 处理内存分配和管理。 CLR 也是一种虚拟机，不仅可执行应用，还可使用 [JIT](https://docs.microsoft.com/zh-cn/dotnet/standard/glossary#jit) 编译器快速生成和编译代码。BCL是.net的基类库，在过去的一些书中，BCL并不被认为是CLR的一部分，但是，现在BCL已经被放在了.NET的runtime开源仓库中，[.NET 5（和 .NET Core）及更高版本](https://docs.microsoft.com/zh-cn/dotnet/standard/glossary#net-5-and-later-versions)的 BCL 的源代码包含在 [.NET 运行时存储库](https://github.com/dotnet/runtime)中。所以BCL应该被看作是CLR的一部分。尽管MSDN仍然会在很多时候将CLR和BCL放在同样的位置却称呼BCL为**运行时库**。

## JIT

> **即时编译**（英语：just-in-time compilation，缩写为**JIT**；又译**及时编译**、**实时编译**），也称为**动态翻译**或**运行时编译**，是一种执行[计算机代码](https://zh.wikipedia.org/wiki/计算机代码)的方法，这种方法涉及在程序执行过程中（在[执行期](https://zh.wikipedia.org/wiki/執行期)）而不是在执行之前进行[编译](https://zh.wikipedia.org/wiki/編譯器)。

JIT也是一个形而上学的概念，现在人们通常将JIT等同于动态翻译。事实上**JIT仅仅是动态翻译的一种实现方式**。**动态编译（dynamic compilation）**指的是“在运行时进行编译”；与之相对的是事前编译（ahead-of-time compilation，简称AOT），也叫静态编译（static compilation）。**JIT编译（just-in-time compilation）**狭义来说是当某段代码即将第一次被执行时进行编译，因而叫“即时编译”。

**在这里，用.NET的JIT编译作为讲解的对象，因为MSDN上有比较官方的说法。**但要注意的是不同的编译器在JIT的实现上是有不同的，就像之前说的，**JIT是一个形而上学的概念。**

> [Smalltalk](https://zh.wikipedia.org/wiki/Smalltalk)（1983年）开创了JIT编译的新领域。例如，按需翻译为机器代码，缓存结果以供以后使用。当内存不足时，系统会删除部分代码，并在需要时重新生成。[[4\]](https://zh.wikipedia.org/wiki/即時編譯#cite_note-FOOTNOTEAycock2003-4)[[21\]](https://zh.wikipedia.org/wiki/即時編譯#cite_note-Schiffman1984-22)Sun的[Self](https://zh.wikipedia.org/wiki/Self)语言广泛地改进了这些技术，一度是世界上速度最快的Smalltalk系统；运用完全面向对象的语言实现了高达优化C语言一半的速度。[[22\]](https://zh.wikipedia.org/wiki/即時編譯#cite_note-23)
>
> Self被Sun抛弃了，但是研究转向了Java语言。“即时编译”这个术语是从制造术语“[及时](https://zh.wikipedia.org/wiki/及時制度)”中借来的，并由Java普及，James Gosling从1993年开始使用这个术语。[[23\]](https://zh.wikipedia.org/wiki/即時編譯#cite_note-FOOTNOTEAycock20032.14_Java,_p._107,_footnote_13-24)目前，大多数[Java虚拟机](https://zh.wikipedia.org/wiki/Java虚拟机)的实现都使用JIT技术，因为[HotSpot](https://zh.wikipedia.org/wiki/HotSpot)创建在这个研究基础之上，而且使用广泛。
>
> ---
>
> 来源：[即时编译 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/即時編譯#历史)

.NET的JIT，从字面上来理解，及时编译，按需编译。

这是.NET的托管代码的执行过程：

> 1. [选择编译器](https://docs.microsoft.com/zh-cn/dotnet/standard/managed-execution-process#choosing_a_compiler)。
>
>    若要获取公共语言运行时提供的好处，必须使用一个或多个面向运行时的语言编译器。
>
> 2. [将代码编译为 MSIL](https://docs.microsoft.com/zh-cn/dotnet/standard/managed-execution-process#compiling_to_msil)。
>
>    编译将你的源代码转换为 Microsoft 中间语言 (MSIL) 并生成必需的元数据。
>
> 3. [将 MSIL 编译为本机代码](https://docs.microsoft.com/zh-cn/dotnet/standard/managed-execution-process#compiling_msil_to_native_code)。
>
>    在执行时，实时 (JIT) 编译器将 MSIL 转换为本机代码。 在此编译期间，代码必须通过检查 MSIL 和元数据的验证过程以查明是否可以将代码确定为类型安全。
>
> 4. [运行代码](https://docs.microsoft.com/zh-cn/dotnet/standard/managed-execution-process#running_code)。
>
>    公共语言运行时提供启用要发生的执行的基础结构以及执行期间可使用的服务。
>
>    ---
>
>    来源：[托管执行过程 | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/standard/managed-execution-process)

简单点说，JIT即时编译器就是把一些经常跑的代码提前编成本地机器码，后面就直接跑机器码，可以跑的更快些。**在人们通常将JIT等同于动态翻译的今天，JIT是一种更聪明、更有效果的动态编译。**

## [What is the difference between Just-in-time compilation and dynamic compilation?](https://stackoverflow.com/questions/48564710/what-is-the-difference-between-just-in-time-compilation-and-dynamic-compilation)

这是一个来自`stack overflow`的问题，也是我关于动态编译最大的困惑，我知道JIT是动态编译的一部分。既然有了JIT，那么常规的动态编译（dynamic compilation）或者解释器（Interpreter）和JIT的区别在哪里呢？就拿python来举例，为什么说cpython的从pyc到**native machine code** 的过程不是JIT呢？

[What is the Difference Between Interpreter and JIT Compiler - Pediaa.Com](https://pediaa.com/what-is-the-difference-between-interpreter-and-jit-compiler/)

[compiler construction - What is the difference between Just-in-time compilation and dynamic compilation? - Stack Overflow](https://stackoverflow.com/questions/48564710/what-is-the-difference-between-just-in-time-compilation-and-dynamic-compilation)

[java - JIT vs Interpreters - Stack Overflow](https://stackoverflow.com/questions/3718024/jit-vs-interpreters)

我试着查阅了一些资料，不止是Wikipedia is confusing，很多人的回答也是令人困惑。所以我得出了一个武断的结论（因为很多网友的说法难以自圆其说，维基百科又是模棱两可），下面是我对我的结论的陈述：

首先，Till now computers don't execute anything other than machine code。现在事实上电脑只能看懂**native machine code**，不管是编译器（compiler）还是解释器（Interpreter）的最终目的只有一个就是让是将便于人编写、阅读、维护的高级计算机语言所写作的[源代码](https://zh.wikipedia.org/wiki/原始碼)程序，翻译为计算机能解读、运行的低阶机器语言的程序，也就是[可执行文件](https://zh.wikipedia.org/wiki/執行檔)。最终让程序运行在电脑上。

编译器追求的是一次性将所有[源代码](https://zh.wikipedia.org/wiki/源代码)编译成二进制文件。

> 一个现代编译器的主要工作流程如下：
>
> [源代码](https://zh.wikipedia.org/wiki/源代码)（source code）→ [预处理器](https://zh.wikipedia.org/wiki/预处理器)（preprocessor）→ [编译器](https://zh.wikipedia.org/wiki/编译器)（compiler）→ [汇编程序](https://zh.wikipedia.org/wiki/汇编程序)（assembler）→ [目标代码](https://zh.wikipedia.org/wiki/目标代码)（object code）→ [链接器](https://zh.wikipedia.org/wiki/链接器)（linker）→ [可执行文件](https://zh.wikipedia.org/wiki/執行檔)（executables），最后打包好的文件就可以给电脑去判读执行了。
>
> ---
>
> 来源：[编译器的工作流程 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/編譯器)

解释器的目的是边解释边执行（by line），因此依赖于解释器的程序启动速度比较缓慢。解释器的好处是它不需要重新编译整个程序，从而减轻了每次程序更新后编译的负担，并且因为解释器往往会有运行时对代码进行分析和处理，运行速度一般会更快（python除外，据我的经验，python运行的真心不快，网上有大佬认为是cpython的设计不科学的问题）。

解释器执行程序的方法一般被认为是下面3种：

> 1. 直接执行高级编程语言（如Shell内建的编译器）
> 2. 转换高级编程语言到更有效率的字节码（Bytecode），并执行字节码
> 3. 用解释器包含的编译器对高级语言进行编译，并指示[中央处理器](https://zh.wikipedia.org/wiki/中央处理器)执行编译后的程序（例如：[JIT](https://zh.wikipedia.org/wiki/JIT)）
>
> ---
>
> 来源：[解释器 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/直譯器#有编译器的高级语言)

python是属于第二种方法，即从源代码全部翻译为到pyc，然后在边解释边执行pyc，执行pyc的过程就是pyc到**native machine code**的过程，当然这个过程里面或许会需要虚拟机（不是真的硬件，而是一种字节码解释器，pyx就相当于虚拟机的**native machine code**）。

JIT编译器的执行过程从大的方面（源代码->字节码->虚拟机运行字节码，将字节码解释为机器代码）来看是和cpython是一致的。

我并不认同“源代码->字节码”这一过程是JIT运行的一部分，我认为“源代码->字节码”是AOT的一部分。在MSDN和维基百科的某些页面上也是这么认为的，MSDN的托管代码执行过程认为**实时 (JIT) 编译器将 MSIL 转换为本机代码**。 维基百科关于解释器的说明中认为**即时编译（Just-in-time compilation）是指一种在执行时期把字节码编译成原生[机器代码](https://zh.wikipedia.org/wiki/機器語言)的技术;这项技术是被用来改善[虚拟机](https://zh.wikipedia.org/wiki/虛擬機器)的性能的**。但是在维基百科的

# 代码混淆

# LICENSE

本文已将所有引用其他文章之内容清楚明白地标注，其他部分皆为作者劳动成果。对作者劳动成果做以下声明：

copyright © 2021 苏月晟，版权所有。

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">作品</span>由<span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">苏月晟</span>采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。不可以商业目的转载和引用此文章，在非商业转载时请注明来源和作者信息，并采用相同的许可协议。如需商业转载需联系作者并取得作者本人同意。

