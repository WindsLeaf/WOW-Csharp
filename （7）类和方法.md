# overload

即方法名称相同、参数列表不同。**满足这两个条件即可，其他的诸如签名是否一样不重要。**

```c#
protected internal string One()
{
    return "验证function overload";
}

protected internal string One(int a)
{
    Console.WriteLine("方法重载");
    string aString = a.ToString();
    return aString;
}

protected internal void One(string str)
{
    Console.WriteLine(str);
}
```

# 拓展方法

**扩展方法使你能够向现有类型“添加”方法，而无需创建新的派生类型、重新编译或以其他方式修改原始类型。** 扩展方法是一种静态方法，但可以像扩展类型上的实例方法一样进行调用。

本质就是对实例化的对象添加方法。

在说拓展方法之前，先讲一下常规意义上我们要对一个实例对象使用方法就是在类里面增加一个非静态方法即可。这种方式必须要修改原来的类。·

先定义一个类，类里面一个属性，一个方法。这不是常规操作，**这个演示只是为了演示，常规时对属性的修改应该通过属性访问器`set`来设定。**

```c#
/// <summary>
/// 常规意义上为实例化对象准备方法
/// </summary>
internal class DefaultFun
{
    internal string Name { get; set; }
    /// <summary>
    /// 可以由实例化对象调用的方法
    /// </summary>
    /// <param name="name">准备的新的属性Name的值</param>
    internal void ChangeName(String name)
    {
        if (name.Length >= 3)
        {
            this.Name = name;
        }
    }
}
```

然后，正常的实例化对象并且调用方法即可：

```c#
//实例化对象
DefaultFun defaultFun = new DefaultFun();
//调用实例化对象的方法
defaultFun.ChangeName("新的Name");
```

但是，如果要对一个别人写的类或者说官方SDK的类增加方法应该怎么办？比如说要对String类增加一个方法，可能很多人的答案是继承，c#提供了一个名为拓展方法的解决方案，**扩展方法使你能够向现有类型“添加”方法，而无需创建新的派生类型、重新编译或以其他方式修改原始类型。** 扩展方法是一种静态方法，但可以像扩展类型上的实例方法一样进行调用。

下面是MSDN上面对定义和调用扩展方法的技术要求：

> ## 定义和调用扩展方法
>
> 1. 定义包含扩展方法的静态[类](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members)。
>
>    此类必须对客户端代码可见。 有关可访问性规则的详细信息，请参阅[访问修饰符](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers)。
>
> 2. 将扩展方法实现为静态方法，并且使其可见性至少与所在类的可见性相同。
>
> 3. **此方法的第一个参数指定方法所操作的类型；此参数前面必须加上 [this](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/this) 修饰符。**
>
> 4. 在调用代码中，添加 `using` 指令，用于指定包含扩展方法类的[命名空间](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/namespace)。
>
> 5. 和调用类型的实例方法那样调用这些方法。
>
>    请注意，第一个参数并不是由调用代码指定，因为它表示要在其上应用运算符的类型，并且编译器已经知道对象的类型。 你只需通过 `n` 提供形参 2 的实参。
>
> ---
>
> 来源：[如何实现和调用自定义扩展方法 - C# 编程指南 | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method)

先按照前三步，定义拓展方法，定义一个静态类，在静态类里面定义静态方法。

```c#
/// <summary>
/// 为string类型增加拓展方法
/// </summary>
internal static class stringExtensions
{
    /// <summary>
    /// demo，试图获取string实例化对象长度的两倍
    /// </summary>
    /// <param name="str">此方法的第一个参数指定方法所操作的类型；此参数前面必须加上 this 修饰符。</param>
    /// <returns>原来长度的两倍</returns>
    internal static int GetTheDoubleLength(this string str)
    {
        return str.Length * 2;
    }
}
```

在使用拓展方法的时候直接调用就行，**直接在实例化对象后面接方法名就行，不用带拓展方法所属于的静态类名。**

```c#
var str = "1234";
//在使用的时候直接调用就行，直接在实例化对象后面接方法名就行，不用带拓展方法所属于的静态类名
int v = str.GetTheDoubleLength();
Console.WriteLine(v);
```

## 拓展方法，多个参数

我们也可以为拓展方法添加除指定方法所操作类型之外的参数，就像下面这样：

```c#
internal static ArrayList GetArrayList(this string str, int a)
{
    string[] strings = new string[str.Length + 1];
    for (int i = 0; i < str.Length; i++)
    {

        strings[i] = str.Substring(i, 1);
    }
    strings[str.Length] = a.ToString();
    ArrayList arrayList = new(strings);
    return arrayList;
}
```

`GetArrayList`这个拓展方法的作用就是将字符串转为结尾为所输入整数参数的arrarylist。调用的时候加上参数即可：

```c#
internal void Four()
{
    var str = "你好世界";
    ArrayList arrayList = str.GetArrayList(12);
    foreach (var item in arrayList)
    {
        Console.WriteLine($"{item.GetType()}\t{item}");
    }
}
```





