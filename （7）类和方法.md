类是一种储存在堆中的引用数据类型，定义的时候可以用类似于`class A{}`的方式来定义，关于类的成员可以参考[类的成员](https://github.com/sogeisetsu/WOW-Csharp/blob/master/（5）c%23基本语法——从格式化字符串到集合.md#类和结构)

# overload

即方法名称相同、参数列表不同。**满足这两个条件即可，其他的诸如签名是否一样不重要。**这种形式又被称为是**重载**或者静态多态性。

```c#
protected internal string One()
{
    return "验证function overload";
}

protected internal string One(int a)
{
    Console.WriteLine("方法重载");
    string aString = a.ToString();
    return aString;
}

protected internal void One(string str)
{
    Console.WriteLine(str);
}
```

# 拓展方法

**扩展方法使你能够向现有类型“添加”方法，而无需创建新的派生类型、重新编译或以其他方式修改原始类型。** 扩展方法是一种静态方法，但可以像扩展类型上的实例方法一样进行调用。

本质就是对实例化的对象添加方法。

在说拓展方法之前，先讲一下常规意义上我们要对一个实例对象使用方法就是在类里面增加一个非静态方法即可。这种方式必须要修改原来的类。·

先定义一个类，类里面一个属性，一个方法。这不是常规操作，**这个演示只是为了演示，常规时对属性的修改应该通过属性访问器`set`来设定。**

```c#
/// <summary>
/// 常规意义上为实例化对象准备方法
/// </summary>
internal class DefaultFun
{
    internal string Name { get; set; }
    /// <summary>
    /// 可以由实例化对象调用的方法
    /// </summary>
    /// <param name="name">准备的新的属性Name的值</param>
    internal void ChangeName(String name)
    {
        if (name.Length >= 3)
        {
            this.Name = name;
        }
    }
}
```

然后，正常的实例化对象并且调用方法即可：

```c#
//实例化对象
DefaultFun defaultFun = new DefaultFun();
//调用实例化对象的方法
defaultFun.ChangeName("新的Name");
```

但是，如果要对一个别人写的类或者说官方SDK的类增加方法应该怎么办？比如说要对String类增加一个方法，可能很多人的答案是继承，c#提供了一个名为拓展方法的解决方案，**扩展方法使你能够向现有类型“添加”方法，而无需创建新的派生类型、重新编译或以其他方式修改原始类型。** 扩展方法是一种静态方法，但可以像扩展类型上的实例方法一样进行调用。

下面是MSDN上面对定义和调用扩展方法的技术要求：

> ## 定义和调用扩展方法
>
> 1. 定义包含扩展方法的静态[类](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members)。
>
>    此类必须对客户端代码可见。 有关可访问性规则的详细信息，请参阅[访问修饰符](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers)。
>
> 2. 将扩展方法实现为静态方法，并且使其可见性至少与所在类的可见性相同。
>
> 3. **此方法的第一个参数指定方法所操作的类型；此参数前面必须加上 [this](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/this) 修饰符。**
>
> 4. 在调用代码中，添加 `using` 指令，用于指定包含扩展方法类的[命名空间](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/namespace)。
>
> 5. 和调用类型的实例方法那样调用这些方法。
>
>    请注意，第一个参数并不是由调用代码指定，因为它表示要在其上应用运算符的类型，并且编译器已经知道对象的类型。 你只需通过 `n` 提供形参 2 的实参。
>
> ---
>
> 来源：[如何实现和调用自定义扩展方法 - C# 编程指南 | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method)

先按照前三步，定义拓展方法，定义一个静态类，在静态类里面定义静态方法。

```c#
/// <summary>
/// 为string类型增加拓展方法
/// </summary>
internal static class stringExtensions
{
    /// <summary>
    /// demo，试图获取string实例化对象长度的两倍
    /// </summary>
    /// <param name="str">此方法的第一个参数指定方法所操作的类型；此参数前面必须加上 this 修饰符。</param>
    /// <returns>原来长度的两倍</returns>
    internal static int GetTheDoubleLength(this string str)
    {
        return str.Length * 2;
    }
}
```

在使用拓展方法的时候直接调用就行，**直接在实例化对象后面接方法名就行，不用带拓展方法所属于的静态类名。**

```c#
var str = "1234";
//在使用的时候直接调用就行，直接在实例化对象后面接方法名就行，不用带拓展方法所属于的静态类名
int v = str.GetTheDoubleLength();
Console.WriteLine(v);
```

## 拓展方法，多个参数

我们也可以为拓展方法添加除指定方法所操作类型之外的参数，就像下面这样：

```c#
internal static ArrayList GetArrayList(this string str, int a)
{
    string[] strings = new string[str.Length + 1];
    for (int i = 0; i < str.Length; i++)
    {

        strings[i] = str.Substring(i, 1);
    }
    strings[str.Length] = a.ToString();
    ArrayList arrayList = new(strings);
    return arrayList;
}
```

`GetArrayList`这个拓展方法的作用就是将字符串转为结尾为所输入整数参数的arrarylist。调用的时候加上参数即可：

```c#
internal void Four()
{
    var str = "你好世界";
    ArrayList arrayList = str.GetArrayList(12);
    foreach (var item in arrayList)
    {
        Console.WriteLine($"{item.GetType()}\t{item}");
    }
}
```

# 继承

继承是对象导向编程的三个主要特性之一，另外两个是封装和多态。 继承可让您建立新的类别，以重复使用、扩展和修改其他类别中定义的行为。

## 基类和派生类

> 继承是面向对象程序设计中最重要的概念之一。继承允许我们根据一个类来定义另一个类，这使得创建和维护应用程序变得更容易。同时也有利于重用代码和节省开发时间。
>
> 当创建一个类时，程序员不需要完全重新编写新的数据成员和成员函数，只需要设计一个新的类，继承了已有的类的成员即可。这个已有的类被称为的**基类**，这个新的类被称为**派生类**。
>
> 继承的思想实现了 **属于（IS-A）** 关系。例如，哺乳动物 **属于（IS-A）** 动物，狗 **属于（IS-A）** 哺乳动物，因此狗 **属于（IS-A）** 动物。
>
> ---
>
> 来源：[C# 继承 | 菜鸟教程 (runoob.com)](https://www.runoob.com/csharp/csharp-inheritance.html)

被继承的类称为是基类，通过继承产生的类被称作是派生类。派生类继承了基类的所有非私有成员。可以用类似于`classA:classB`来定义classA继承了classB。

比如先定义一个基类`ClassA`：

```c#
/// <summary>
/// 基类
/// </summary>
public class ClassA
{
    public int age = 10;
    private int _score;

    public int Score
    {
        get { return _score; }
        set { _score = value; }
    }

    public void AMethod()
    {
        Console.WriteLine("基类的方法");
    }

}
```

然后用`public class ClassB : ClassA`来声明`ClassA`的派生类`ClassB`：

```c#
public class ClassB : ClassA
{

}
```

派生类继承了基类的所有非私有成员，实例化一个`ClassB`之后，可以调用基类的所有非私有成员。

```c#
ClassB classB = new ClassB();
// 调用基类的方法
classB.AMethod();
```

### 转型

先说一个尝试，声明的所有类本质上都是System.Object的派生类。`ClassA`和`ClassB`的继承关系如下图所示：

![](https://suyuesheng-biaozhun-blog-tupian.oss-cn-qingdao.aliyuncs.com/blogimg/20211212203503.png)



在实例化一个类的时候所**声明的类型**可以是基类，也可以是自己。换句话说就是**实例化对象可以指向其基类也可以指向自己本身的类型。**下面这两种实例化对象的方式都是**合法**的：

```c#
ClassB classB = new ClassB();
ClassA classA = new ClassB();
```

**实例化对象如果指向基类，那么该实例化对象只能调用其所从基类继承和重写而来的成员。**

如果在创建类`ClassB`的时候，在继承`ClassA`的同时自己有自己专属的成员：

```c#
public class ClassB : ClassA
{
    public int High { get; init; }
}
```

只有在实例化时指向自己（`ClassB classB = new ClassB();`）才可以调用自己专属的成员`High`。

如果采用`ClassA classA = new ClassB();`将其指向基类则只可以调用从基类继承而来的成员，这就被称作**向上转型**。如果一个基类有多个派生类，那么这些派生类在实例化的时候如果采取向上转型有利于成员的统一。

既然有向上转型就有向下转型，**向下转型**就是将实例化对象指向自己的派生类，就像下面这样：

```c#
ClassA classA = new ClassB();//向上转型
ClassB classBDown = (ClassB)classA;//向下转型
```

其实所谓的**向下转型**就是数据类型转换的**显式转换**。**向下转型是为了调用子类中的特殊成员**。

|      | 向下转型                                                     | 向上转型                                |
| ---- | ------------------------------------------------------------ | --------------------------------------- |
| 实现 | ClassA classA = new ClassB();//向上转型<br/>ClassB classBDown = (ClassB)classA;//向下转型 | ClassA classA = new ClassB();//向上转型 |
| 目的 | 调用子类中的特殊成员                                         | 有利于成员的统一                        |

实例化对象只能调用自己所指向的类的成员。

# LICENSE

已将所有引用其他文章之内容清楚明白地标注，其他部分皆为作者劳动成果。对作者劳动成果做以下声明：

copyright © 2021 苏月晟，版权所有。

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">作品</span>由<span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">苏月晟</span>采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。

