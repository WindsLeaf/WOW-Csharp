类是一种储存在堆中的引用数据类型，定义的时候可以用类似于`class A{}`的方式来定义，关于类的成员可以参考[类的成员](https://github.com/sogeisetsu/WOW-Csharp/blob/master/（5）c%23基本语法——从格式化字符串到集合.md#类和结构)

# overload

即方法名称相同、参数列表不同。**满足这两个条件即可，其他的诸如签名是否一样不重要。**这种形式又被称为是**重载**或者静态多态性。

```c#
protected internal string One()
{
    return "验证function overload";
}

protected internal string One(int a)
{
    Console.WriteLine("方法重载");
    string aString = a.ToString();
    return aString;
}

protected internal void One(string str)
{
    Console.WriteLine(str);
}
```

# 拓展方法

**扩展方法使你能够向现有类型“添加”方法，而无需创建新的派生类型、重新编译或以其他方式修改原始类型。** 扩展方法是一种静态方法，但可以像扩展类型上的实例方法一样进行调用。

本质就是对实例化的对象添加方法。

在说拓展方法之前，先讲一下常规意义上我们要对一个实例对象使用方法就是在类里面增加一个非静态方法即可。这种方式必须要修改原来的类。·

先定义一个类，类里面一个属性，一个方法。这不是常规操作，**这个演示只是为了演示，常规时对属性的修改应该通过属性访问器`set`来设定。**

```c#
/// <summary>
/// 常规意义上为实例化对象准备方法
/// </summary>
internal class DefaultFun
{
    internal string Name { get; set; }
    /// <summary>
    /// 可以由实例化对象调用的方法
    /// </summary>
    /// <param name="name">准备的新的属性Name的值</param>
    internal void ChangeName(String name)
    {
        if (name.Length >= 3)
        {
            this.Name = name;
        }
    }
}
```

然后，正常的实例化对象并且调用方法即可：

```c#
//实例化对象
DefaultFun defaultFun = new DefaultFun();
//调用实例化对象的方法
defaultFun.ChangeName("新的Name");
```

但是，如果要对一个别人写的类或者说官方SDK的类增加方法应该怎么办？比如说要对String类增加一个方法，可能很多人的答案是继承，c#提供了一个名为拓展方法的解决方案，**扩展方法使你能够向现有类型“添加”方法，而无需创建新的派生类型、重新编译或以其他方式修改原始类型。** 扩展方法是一种静态方法，但可以像扩展类型上的实例方法一样进行调用。

下面是MSDN上面对定义和调用扩展方法的技术要求：

> ## 定义和调用扩展方法
>
> 1. 定义包含扩展方法的静态[类](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members)。
>
>    此类必须对客户端代码可见。 有关可访问性规则的详细信息，请参阅[访问修饰符](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers)。
>
> 2. 将扩展方法实现为静态方法，并且使其可见性至少与所在类的可见性相同。
>
> 3. **此方法的第一个参数指定方法所操作的类型；此参数前面必须加上 [this](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/this) 修饰符。**
>
> 4. 在调用代码中，添加 `using` 指令，用于指定包含扩展方法类的[命名空间](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/namespace)。
>
> 5. 和调用类型的实例方法那样调用这些方法。
>
>    请注意，第一个参数并不是由调用代码指定，因为它表示要在其上应用运算符的类型，并且编译器已经知道对象的类型。 你只需通过 `n` 提供形参 2 的实参。
>
> ---
>
> 来源：[如何实现和调用自定义扩展方法 - C# 编程指南 | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method)

先按照前三步，定义拓展方法，定义一个静态类，在静态类里面定义静态方法。

```c#
/// <summary>
/// 为string类型增加拓展方法
/// </summary>
internal static class stringExtensions
{
    /// <summary>
    /// demo，试图获取string实例化对象长度的两倍
    /// </summary>
    /// <param name="str">此方法的第一个参数指定方法所操作的类型；此参数前面必须加上 this 修饰符。</param>
    /// <returns>原来长度的两倍</returns>
    internal static int GetTheDoubleLength(this string str)
    {
        return str.Length * 2;
    }
}
```

在使用拓展方法的时候直接调用就行，**直接在实例化对象后面接方法名就行，不用带拓展方法所属于的静态类名。**

```c#
var str = "1234";
//在使用的时候直接调用就行，直接在实例化对象后面接方法名就行，不用带拓展方法所属于的静态类名
int v = str.GetTheDoubleLength();
Console.WriteLine(v);
```

## 拓展方法，多个参数

我们也可以为拓展方法添加除指定方法所操作类型之外的参数，就像下面这样：

```c#
internal static ArrayList GetArrayList(this string str, int a)
{
    string[] strings = new string[str.Length + 1];
    for (int i = 0; i < str.Length; i++)
    {

        strings[i] = str.Substring(i, 1);
    }
    strings[str.Length] = a.ToString();
    ArrayList arrayList = new(strings);
    return arrayList;
}
```

`GetArrayList`这个拓展方法的作用就是将字符串转为结尾为所输入整数参数的arrarylist。调用的时候加上参数即可：

```c#
internal void Four()
{
    var str = "你好世界";
    ArrayList arrayList = str.GetArrayList(12);
    foreach (var item in arrayList)
    {
        Console.WriteLine($"{item.GetType()}\t{item}");
    }
}
```

# 继承

继承是对象导向编程的三个主要特性之一，另外两个是封装和多态。 继承可让您建立新的类别，以重复使用、扩展和修改其他类别中定义的行为。

## 基类和派生类

> 继承是面向对象程序设计中最重要的概念之一。继承允许我们根据一个类来定义另一个类，这使得创建和维护应用程序变得更容易。同时也有利于重用代码和节省开发时间。
>
> 当创建一个类时，程序员不需要完全重新编写新的数据成员和成员函数，只需要设计一个新的类，继承了已有的类的成员即可。这个已有的类被称为的**基类**，这个新的类被称为**派生类**。
>
> 继承的思想实现了 **属于（IS-A）** 关系。例如，哺乳动物 **属于（IS-A）** 动物，狗 **属于（IS-A）** 哺乳动物，因此狗 **属于（IS-A）** 动物。
>
> ---
>
> 来源：[C# 继承 | 菜鸟教程 (runoob.com)](https://www.runoob.com/csharp/csharp-inheritance.html)

被继承的类称为是基类，通过继承产生的类被称作是派生类。派生类继承了基类的所有非私有成员。可以用类似于`classA:classB`来定义`classA`继承了`classB`。

一个派生类只能继承自一个基类，这被称作是**单继承局限**。如果想要打破单继承局限需要使用接口。

比如先定义一个基类`ClassA`：

```c#
/// <summary>
/// 基类
/// </summary>
public class ClassA
{
    public int age = 10;
    private int _score;

    public int Score
    {
        get { return _score; }
        set { _score = value; }
    }

    public void AMethod()
    {
        Console.WriteLine("基类的方法");
    }

}
```

然后用`public class ClassB : ClassA`来声明`ClassA`的派生类`ClassB`：

```c#
public class ClassB : ClassA
{

}
```

派生类继承了基类的所有非私有成员，实例化一个`ClassB`之后，可以调用基类的所有非私有成员。

```c#
ClassB classB = new ClassB();
// 调用基类的方法
classB.AMethod();
```

### 转型

先说一个尝试，声明的所有类本质上都是`System.Object`的派生类。`ClassA`和`ClassB`的继承关系如下图所示：

![](https://suyuesheng-biaozhun-blog-tupian.oss-cn-qingdao.aliyuncs.com/blogimg/20211212203503.png)



在实例化一个类的时候所**声明的类型**可以是基类，也可以是自己。换句话说就是**实例化对象可以指向其基类也可以指向自己本身的类型。**下面这两种实例化对象的方式都是**合法**的：

```c#
ClassB classB = new ClassB();
ClassA classA = new ClassB();
```

**实例化对象如果指向基类，那么该实例化对象只能调用其所从基类继承和重写而来的成员。**

如果在创建类`ClassB`的时候，在继承`ClassA`的同时自己有自己专属的成员：

```c#
public class ClassB : ClassA
{
    public int High { get; init; }
}
```

只有在实例化时指向自己（`ClassB classB = new ClassB();`）才可以调用自己专属的成员`High`。

如果采用`ClassA classA = new ClassB();`将其指向基类则只可以调用从基类继承而来的成员，这就被称作**向上转型**。如果一个基类有多个派生类，那么这些派生类在实例化的时候如果采取向上转型有利于成员的统一。

既然有向上转型就有向下转型，**向下转型**就是将实例化对象指向自己的派生类，就像下面这样：

```c#
ClassA classA = new ClassB();//向上转型
ClassB classBDown = (ClassB)classA;//向下转型
```

其实所谓的**向下转型**就是数据类型转换的**显式转换**。**向下转型是为了调用子类中的特殊成员**。

|      | 向下转型                                                     | 向上转型                                  |
| ---- | ------------------------------------------------------------ | ----------------------------------------- |
| 实现 | `ClassA classA = new ClassB();//向上转型`<br/>`ClassB classBDown = (ClassB)classA;//向下转型` | `ClassA classA = new ClassB();//向上转型` |
| 目的 | 调用子类中的特殊成员                                         | 有利于成员的统一                          |

实例化对象只能调用自己所指向的类的成员。

### override

`override`可以被称为重写，也可以被称为**动态多态性**，本质上是扩展或修改继承的方法、属性、索引器或事件的抽象或虚拟实现。

之前说到，所有的类都是`System.Object`的派生类，`System.Object`有一个方法叫做`ToString()`返回被打印时的数据，此方法可以在类中进行重写：

```c#
public override string ToString()
{
    return $"此类被打印{MethodBase.GetCurrentMethod().DeclaringType.FullName}";
}
```

之所以这个方法可以被重写是因为`ToString()`这个方法在`System.Object`中用`virtual`来修饰。

**`virtual` 关键字用于修改方法、属性、索引器或事件声明，并使它们可以在派生类中被重写。`override` 修饰符用于扩展基类 `virtual` 方法。**

可以看到想要重写基类的方法需要两个条件：

1. 此方法在基类中用`virtual`修饰，变为虚拟方法。
2. 在派生类中使用`override`修饰基类的`virtual`方法。

**注意**：`virtual` 修饰符不能与 `static`、`abstract`、`private` 或 `override` 修饰符一起使用。

demo如下：

定义基类`ClassA`，有一个虚拟属性和一个虚拟方法：

```c#
/// <summary>
/// 基类
/// </summary>
public class ClassA
{
 
    /// <summary>
    /// 虚拟属性
    /// </summary>
    public virtual int Width { get; set; }
    
    /// <summary>
    /// 虚拟方法
    /// </summary>
    public virtual void AMethod()
    {
        Console.WriteLine("基类的虚拟方法");
    }
 
}
```

定义基类`ClassA`的派生类`ClassB`，并重写基类的虚拟属性`Width`和虚拟方法`AMethod()`：

```c#
/// <summary>
/// 派生类
/// </summary>
public class ClassB : ClassA
{
 
    /// <summary>
    /// 重写基类的虚拟方法
    /// </summary>
    public override void AMethod()
    {
        Console.WriteLine("重写基类的虚拟方法");
    }
 
    private int _width = 10;
 
    /// <summary>
    /// 重写基类的虚拟属性
    /// </summary>
    public override int Width
    {
        get
        {
            return this._width;
        }
        set
        {
            if (value >= 0)
            {
                this._width = value;
            }
        }
    }
}
```

注意：**基类的派生类的派生类**可以直接重写基类中的虚拟成员，无需在**基类的派生类**中进行二次声明`virtual`。

### base和this

`this` 关键字指代类的当前实例，`base` 关键字用于从派生类中访问基类的成员，不能在静态方法中使用`base`关键字。

以下是MSDN中指出的 `this` 的常见用法：

- 限定类似名称隐藏的成员，例如：

  ```csharp
  public class Employee
  {
      private string alias;
      private string name;
  
      public Employee(string name, string alias)
      {
          // Use this to qualify the members of the class
          // instead of the constructor parameters.
          this.name = name;
          this.alias = alias;
      }
  }
  ```

- 将对象作为参数传递给方法，例如：

  ```csharp
  CalcTax(this);
  ```

- 声明索引器，例如：

  ```csharp
  public int this[int param]
  {
      get { return array[param]; }
      set { array[param] = value; }
  }
  ```

静态成员函数，因为它们存在于类级别且不属于对象，不具有 `this` 指针。 **在静态方法中引用 `this` 会生成错误。**this还可以用于拓展方法，关于扩展方法的使用请查看[WOW-Csharp/（7）类和方法.md at master · sogeisetsu/WOW-Csharp (github.com)](https://github.com/sogeisetsu/WOW-Csharp/blob/master/（7）类和方法.md#拓展方法)。

当用`this`来访问本类的成员时，会优先从本类已有和已经override的成员中查找，如果本类没有就从基类查找。

```c#
        public void TestBaseMethod()
        {
            Console.WriteLine($"派生类没有override的成员this.Score\t{this.Score}");
            Console.WriteLine($"通过base访问派生类没有override的成员base.Score\t{base.Score}");
            Console.WriteLine($"base.Score == this.Score\t{base.Score == this.Score}");
            Console.WriteLine($"派生类已经override的成员this.Width\t{this.Width}");
            Console.WriteLine($"通过base访问已经在派生类中重写的成员base.Width\t{base.Width}");
            Console.WriteLine($"base.Width==this.Width\t{base.Width == this.Width}");

            /*
            派生类没有override的成员this.Score      0
            通过base访问派生类没有override的成员base.Score  0
            base.Score == this.Score        True
            派生类已经override的成员this.Width      10
            通过base访问已经在派生类中重写的成员base.Width  0
            base.Width==this.Width  False
             */
        }
```

`base` 关键字用于从派生类中访问基类的成员：

- 调用基类上已被其他方法重写的方法。

  ```c#
  /// <summary>
  /// 重写基类的方法
  /// </summary>
  /// <param name="name"> </param>
  public override void GetName(string name)
  {
      Console.WriteLine(base.Age);
      base.GetName(name);
      Console.WriteLine(MethodBase.GetCurrentMethod().Name);
  }
  ```

- 指定创建派生类实例时应调用的基类构造函数。

  ```c#
  /// <summary>
  /// 调用基类的构造函数
  /// </summary>
  /// <param name="age"> 年龄 </param>
  /// <param name="sex"> 性别 </param>
  public Students(int age, string sex) : base(age, sex)
  {
  }
  ```

从静态方法中使用 `base` 关键字是错误的。

#### 区别

|          | this                                                         | base                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------ |
| 成员访问 | 访问本类中的成员，<br>如果本类没有此成员则从基类类中继续查找 | 访问基类的成员                             |
| 表示对象 | 表示当前对象                                                 | 无此概念                                   |
| 构造函数 |                                                              | 指定创建派生类实例时应调用的基类构造函数。 |
| 静态     | 不能在静态成员中调用                                         | 不能在静态成员中调用                       |

**`base`和`this`都不可以在静态成员中使用，也无法通过`this`与`base`调用静态成员。**原因是因为`this`与`base`**某种程度**上来说表示的是实例对象(`base`属于不完整的实例对象)，而静态成员的调用存在类级别并且不属于对象。

### 禁止继承

`sealed`用于在声明类的时候修饰类。应用于某个类时，`sealed` 修饰符可阻止其他类继承自该类。在下面的示例中，没有类可以继承`BanInherit`，因为其被`sealed`修饰。

```c#
/// <summary>
/// 该类禁止被继承
/// </summary>
public sealed class BanInherit
{

}
```

## 抽象

`abstract` 修饰符指示被修改内容的实现已丢失或不完整。 **abstract 修饰符可用于类、方法、属性、索引和事件。** 在类声明中使用 `abstract` 修饰符来指示某个类仅用作其他类的基类，**而不用于自行进行实例化。** 标记为**抽象的成员必须由派生自抽象类的非抽象类来实现。**只有**在抽象类中才可以用`abstract`修饰成员。抽象类中可以包含非抽象成员。**

```c#
    /// <summary>
    /// 抽象类，抽象类不能实例化
    /// </summary>
    public abstract class Human
    {
        private int _age = 1;

        /// <summary>
        /// 非抽象成员
        /// </summary>
        public int Age
        {
            get { return _age; }
            set
            {
                if (value > 0)
                {
                    this._age = value;
                }
            }
        }

        /// <summary>
        /// 抽象属性,不能设定值
        /// </summary>
        public abstract string Name { get; set; }

        /// <summary>
        /// 抽象方法
        /// </summary>
        public abstract void AbstrractMethod();
    }
```

由于抽象方法声明不提供实际的实现，因此没有方法主体；方法声明仅以分号结尾，且签名后没有大括号 ({ })。

```c#
/// <summary>
/// 抽象方法
/// </summary>
public abstract void AbstrractMethod();
```

抽象属性不能设定默认值。

```c#
/// <summary>
/// 抽象属性,不能设定值
/// </summary>
public abstract string Name { get; set; }
```

如果一个类继承了抽象类，则其必须override抽象类中所有的抽象成员。

```c#
/// <summary>
/// 抽象类的派生类，抽象类的派生类必须实现抽象类的所有抽象成员，sealed禁止此类有派生类
/// </summary>
public sealed class Tom : Human
{
    public Tom()
    {
    }

    public Tom(string name)
    {
        Name = name;
    }

    /// <summary>
    /// 构造函数
    /// </summary>
    /// <param name="name"> 姓名 </param>
    /// <param name="age"> 年龄 </param>
    public Tom(string name, int age)
    {
        this.Age = age;
        this.Name = name;
    }

    public override string Name { get; set; } = "Tom";

    public override void AbstrractMethod()
    {
        Console.WriteLine("实现抽象类的抽象方法");
    }
}
```

**总结：**

- 用关键字`abstract`来表示抽象。
-  `abstract` 修饰符可用于类、方法、属性、索引和事件。
- `abstract`修饰的类被称作是抽象类。
  - **抽象类不能是密封或者静态的。**
  - **只有在抽象类中才可以定义抽象成员。**
  - 抽象类**不能被实例化。**
- 如果一个类A继承自抽象类，则该抽象类的**所有抽象成员**必须由A通过override修饰符来进行实现。
- 抽象类**可以包含非抽象成员。**
- **抽象类中的抽象成员不能在抽象类中有实际的实现**，即抽象方法没有方法主体；方法声明仅以分号结尾，且签名后没有大括号。抽象属性不能设定初始值。
- 抽象成员**不能是静态**的。
- 抽象类不能被 `sealed` 修饰，抽象成员不能被`virtual`修饰。 `sealed` 修饰符阻止类被继承，而 `abstract` 修饰符要求类被继承，两个的意思完全相反。

**抽象类和普通类一样有单继承局限。**抽象类多用于模板设计。

## 接口



# LICENSE

已将所有引用其他文章之内容清楚明白地标注，其他部分皆为作者劳动成果。对作者劳动成果做以下声明：

copyright © 2021 苏月晟，版权所有。

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">作品</span>由<span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">苏月晟</span>采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。

